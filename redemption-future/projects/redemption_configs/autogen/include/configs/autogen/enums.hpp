// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#pragma once

#include <cstdint>


template<class E> struct is_valid_enum_value {};

enum class ModuleName : uint8_t
{
    UNKNOWN = 0,
    login = 1,
    selector = 2,
    confirm = 3,
    link_confirm = 4,
    challenge = 5,
    valid = 6,
    transitory = 7,
    close = 8,
    close_back = 9,
    interactive_target = 10,
    RDP = 11,
    VNC = 12,
    INTERNAL = 13,
    waitinfo = 14,
    bouncer2 = 15,
    autotest = 16,
    widgettest = 17,
    card = 18,
};

template<> struct is_valid_enum_value<ModuleName>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 18; }
};

// Specifies the type of data to be captured:
enum class CaptureFlags : uint8_t
{
    none = 0,
    png = 1,
    // Session recording file.
    wrm = 2,
    video = 4,
    ocr = 8,
};

template<> struct is_valid_enum_value<CaptureFlags>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 15; }
};

inline CaptureFlags operator | (CaptureFlags x, CaptureFlags y)
{
    return static_cast<CaptureFlags>(
        static_cast<uint8_t>(x) | static_cast<uint8_t>(y)
    );
}

inline CaptureFlags operator & (CaptureFlags x, CaptureFlags y)
{
    return static_cast<CaptureFlags>(
        static_cast<uint8_t>(x) & static_cast<uint8_t>(y)
    );
}

inline CaptureFlags operator ~ (CaptureFlags x)
{
    return static_cast<CaptureFlags>(
        ~static_cast<uint8_t>(x) & 15
    );
}

inline CaptureFlags & operator |= (CaptureFlags & x, CaptureFlags y) { return x = x | y; }
inline CaptureFlags & operator &= (CaptureFlags & x, CaptureFlags y) { return x = x & y; }

enum class RdpSecurityEncryptionLevel : uint8_t
{
    none = 0,
    low = 1,
    medium = 2,
    high = 3,
};

template<> struct is_valid_enum_value<RdpSecurityEncryptionLevel>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 3; }
};

enum class Language : uint8_t
{
    en = 0,
    fr = 1,
};

template<> struct is_valid_enum_value<Language>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 1; }
};

enum class ClipboardEncodingType : uint8_t
{
    utf8 = 0,
    latin1 = 1,
};

template<> struct is_valid_enum_value<ClipboardEncodingType>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 1; }
};

enum class KeyboardLogFlags : uint8_t
{
    none = 0,
    // keyboard log in session log
    session_log = 1,
    // keyboard log in recorded sessions
    wrm = 2,
};

template<> struct is_valid_enum_value<KeyboardLogFlags>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 3; }
};

inline KeyboardLogFlags operator | (KeyboardLogFlags x, KeyboardLogFlags y)
{
    return static_cast<KeyboardLogFlags>(
        static_cast<uint8_t>(x) | static_cast<uint8_t>(y)
    );
}

inline KeyboardLogFlags operator & (KeyboardLogFlags x, KeyboardLogFlags y)
{
    return static_cast<KeyboardLogFlags>(
        static_cast<uint8_t>(x) & static_cast<uint8_t>(y)
    );
}

inline KeyboardLogFlags operator ~ (KeyboardLogFlags x)
{
    return static_cast<KeyboardLogFlags>(
        ~static_cast<uint8_t>(x) & 3
    );
}

inline KeyboardLogFlags & operator |= (KeyboardLogFlags & x, KeyboardLogFlags y) { return x = x | y; }
inline KeyboardLogFlags & operator &= (KeyboardLogFlags & x, KeyboardLogFlags y) { return x = x & y; }

enum class ClipboardLogFlags : uint8_t
{
    none = 0,
    // clipboard log in recorded sessions
    wrm = 1,
    // clipboard log in recorded meta
    meta = 2,
};

template<> struct is_valid_enum_value<ClipboardLogFlags>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 3; }
};

inline ClipboardLogFlags operator | (ClipboardLogFlags x, ClipboardLogFlags y)
{
    return static_cast<ClipboardLogFlags>(
        static_cast<uint8_t>(x) | static_cast<uint8_t>(y)
    );
}

inline ClipboardLogFlags operator & (ClipboardLogFlags x, ClipboardLogFlags y)
{
    return static_cast<ClipboardLogFlags>(
        static_cast<uint8_t>(x) & static_cast<uint8_t>(y)
    );
}

inline ClipboardLogFlags operator ~ (ClipboardLogFlags x)
{
    return static_cast<ClipboardLogFlags>(
        ~static_cast<uint8_t>(x) & 3
    );
}

inline ClipboardLogFlags & operator |= (ClipboardLogFlags & x, ClipboardLogFlags y) { return x = x | y; }
inline ClipboardLogFlags & operator &= (ClipboardLogFlags & x, ClipboardLogFlags y) { return x = x & y; }

enum class FileSystemLogFlags : uint8_t
{
    none = 0,
    // (redirected) file system log in recorded sessions
    wrm = 1,
    // (redirected) file system log in recorded meta
    meta = 2,
};

template<> struct is_valid_enum_value<FileSystemLogFlags>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 3; }
};

inline FileSystemLogFlags operator | (FileSystemLogFlags x, FileSystemLogFlags y)
{
    return static_cast<FileSystemLogFlags>(
        static_cast<uint8_t>(x) | static_cast<uint8_t>(y)
    );
}

inline FileSystemLogFlags operator & (FileSystemLogFlags x, FileSystemLogFlags y)
{
    return static_cast<FileSystemLogFlags>(
        static_cast<uint8_t>(x) & static_cast<uint8_t>(y)
    );
}

inline FileSystemLogFlags operator ~ (FileSystemLogFlags x)
{
    return static_cast<FileSystemLogFlags>(
        ~static_cast<uint8_t>(x) & 3
    );
}

inline FileSystemLogFlags & operator |= (FileSystemLogFlags & x, FileSystemLogFlags y) { return x = x | y; }
inline FileSystemLogFlags & operator &= (FileSystemLogFlags & x, FileSystemLogFlags y) { return x = x & y; }

// Specifies the maximum color depth for the client connection session:
enum class ColorDepth : uint8_t
{
    // 8-bit
    depth8 = 8,
    // 15-bit 555 RGB mask
    depth15 = 15,
    // 16-bit 565 RGB mask
    depth16 = 16,
    // 24-bit RGB mask
    depth24 = 24,
    // 32-bit RGB mask + alpha
    depth32 = 32,
};

template<> struct is_valid_enum_value<ColorDepth>
{
    constexpr static bool is_valid(uint64_t n)
    {
        switch (n) {
        case 8u:
        case 15u:
        case 16u:
        case 24u:
        case 32u:
            return true;
        }
        return false;
    }

};

enum class ServerCertNotification : uint8_t
{
    nobody = 0,
    // message sent to SIEM
    SIEM = 1,
};

template<> struct is_valid_enum_value<ServerCertNotification>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 1; }
};

inline ServerCertNotification operator | (ServerCertNotification x, ServerCertNotification y)
{
    return static_cast<ServerCertNotification>(
        static_cast<uint8_t>(x) | static_cast<uint8_t>(y)
    );
}

inline ServerCertNotification operator & (ServerCertNotification x, ServerCertNotification y)
{
    return static_cast<ServerCertNotification>(
        static_cast<uint8_t>(x) & static_cast<uint8_t>(y)
    );
}

inline ServerCertNotification operator ~ (ServerCertNotification x)
{
    return static_cast<ServerCertNotification>(
        ~static_cast<uint8_t>(x) & 1
    );
}

inline ServerCertNotification & operator |= (ServerCertNotification & x, ServerCertNotification y) { return x = x | y; }
inline ServerCertNotification & operator &= (ServerCertNotification & x, ServerCertNotification y) { return x = x & y; }

// Behavior of certificates check.
// System errors like FS access rights issues or certificate decode are always check errors leading to connection rejection.
enum class ServerCertCheck : uint8_t
{
    // fails if certificates do not match or are missing.
    fails_if_no_match_or_missing = 0,
    // fails if certificate does not match, succeeds if no known certificate.
    fails_if_no_match_and_succeed_if_no_know = 1,
    // succeeds if certificates exist (not checked), fails if missing.
    succeed_if_exists_and_fails_if_missing = 2,
    // always succeed.
    always_succeed = 3,
};

template<> struct is_valid_enum_value<ServerCertCheck>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 3; }
};

// Session record options.
// When session records are encrypted, they can be read only by the WALLIX Bastion where they have been generated.
enum class TraceType : uint8_t
{
    // No encryption (faster).
    localfile = 0,
    // No encryption, with checksum.
    localfile_hashed = 1,
    // Encryption enabled.
    cryptofile = 2,
};

template<> struct is_valid_enum_value<TraceType>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

enum class KeyboardInputMaskingLevel : uint8_t
{
    // Keyboard inputs are not masked.
    unmasked = 0,
    // Only passwords are masked.
    password_only = 1,
    // Passwords and unidentified texts are masked.
    password_and_unidentified = 2,
    // Keyboard inputs are not logged.
    fully_masked = 3,
};

template<> struct is_valid_enum_value<KeyboardInputMaskingLevel>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 3; }
};

// Behavior on failure to launch Session Probe.
enum class SessionProbeOnLaunchFailure : uint8_t
{
    // The metadata collected is not essential for us. Instead, we prefer to minimize the impact on the user experience. The Session Probe launch will be in best-effort mode. The prevailing duration is defined by the 'Launch fallback timeout' instead of the 'Launch timeout'.
    ignore_and_continue = 0,
    // This is the recommended setting. If the target meets all the technical prerequisites, there is no reason for the Session Probe not to launch. All that remains is to adapt the value of 'Launch timeout' to the performance of the target.
    disconnect_user = 1,
    // We wish to be able to recover the behavior of Bastion 5 when the Session Probe does not launch. The prevailing duration is defined by the 'Launch fallback timeout' instead of the 'Launch timeout'.
    retry_without_session_probe = 2,
};

template<> struct is_valid_enum_value<SessionProbeOnLaunchFailure>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

enum class VncBogusClipboardInfiniteLoop : uint8_t
{
    // Clipboard processing is deferred and, if necessary, the token is left with the client.
    delayed = 0,
    // When 2 identical requests are received, the second is ignored. This can block clipboard data reception until a clipboard event is triggered on the target server when the client clipboard is blocked, and vice versa.
    duplicated = 1,
    // No special processing is done, the proxy always responds immediately.
    continued = 2,
};

template<> struct is_valid_enum_value<VncBogusClipboardInfiniteLoop>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

// Color depth for the Session Recording file (.wrm):
enum class ColorDepthSelectionStrategy : uint8_t
{
    // 24-bit
    depth24 = 0,
    // 16-bit
    depth16 = 1,
};

template<> struct is_valid_enum_value<ColorDepthSelectionStrategy>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 1; }
};

// Compression method of the Session Recording file (.wrm):
enum class WrmCompressionAlgorithm : uint8_t
{
    no_compression = 0,
    // GZip: Files are better compressed, but this takes more time and CPU load.
    gzip = 1,
    // Snappy: Faster than GZip, but files are less compressed.
    snappy = 2,
};

template<> struct is_valid_enum_value<WrmCompressionAlgorithm>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

// Specifies the highest RDP compression support available
enum class RdpCompression : uint8_t
{
    // The RDP bulk compression is disabled
    none = 0,
    // RDP 4.0 bulk compression
    rdp4 = 1,
    // RDP 5.0 bulk compression
    rdp5 = 2,
    // RDP 6.0 bulk compression
    rdp6 = 3,
    // RDP 6.1 bulk compression
    rdp6_1 = 4,
};

template<> struct is_valid_enum_value<RdpCompression>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 4; }
};

enum class OcrVersion : uint8_t
{
    v1 = 1,
    v2 = 2,
};

template<> struct is_valid_enum_value<OcrVersion>
{
    constexpr static bool is_valid(uint64_t n)
    {
        switch (n) {
        case 1u:
        case 2u:
            return true;
        }
        return false;
    }

};

enum class OcrLocale : uint8_t
{
    // Recognizes Latin characters
    latin = 0,
    // Recognizes Latin and Cyrillic characters
    cyrillic = 1,
};

template<> struct is_valid_enum_value<OcrLocale>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 1; }
};

enum class SessionProbeOnKeepaliveTimeout : uint8_t
{
    // Designed to minimize the impact on the user experience if the Session Probe is unstable. It should not be used when Session Probe is working well. An attacker can take advantage of this setting by simulating a Session Probe crash in order to bypass the surveillance.
    ignore_and_continue = 0,
    // Legacy behavior. It’s a choice that gives more security, but the impact on the user experience seems disproportionate. The RDP session can be closed (resulting in the permanent loss of all its unsaved elements) if the 'End disconnected session' parameter (or an equivalent setting at the RDS-level) is enabled.
    disconnect_user = 1,
    // This is the recommended setting. User actions will be blocked until contact with the Session Probe (reply to KeepAlive message or something else) is resumed.
    freeze_connection_and_wait = 2,
};

template<> struct is_valid_enum_value<SessionProbeOnKeepaliveTimeout>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

enum class SmartVideoCropping : uint8_t
{
    // When replaying the session video, the content of the RDP viewer matches the size of the client's desktop.
    disable = 0,
    // When replaying the session video, the content of the RDP viewer is restricted to the greatest area covered by the application during the session.
    v1 = 1,
    // When replaying the session video, the content of the RDP viewer is fully covered by the size of the greatest application window during the session.
    v2 = 2,
};

template<> struct is_valid_enum_value<SmartVideoCropping>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

enum class RdpModeConsole : uint8_t
{
    // Forward Console mode request from client to the target.
    allow = 0,
    // Force Console mode on target regardless of client request.
    force = 1,
    // Block Console mode request from client.
    forbid = 2,
};

template<> struct is_valid_enum_value<RdpModeConsole>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

enum class SessionProbeDisabledFeature : uint16_t
{
    none = 0,
    // Java Access Bridge. General user activity monitoring in the Java applications (including detection of password fields).
    jab = 1,
    // MS Active Accessbility. General user activity monitoring (including detection of password fields). (legacy API)
    msaa = 2,
    // MS UI Automation. General user activity monitoring (including detection of password fields). (new API)
    msuia = 4,
    // Inspect Edge location URL. Basic web navigation monitoring.
    edge_inspection = 16,
    // Inspect Chrome Address/Search bar. Basic web navigation monitoring.
    chrome_inspection = 32,
    // Inspect Firefox Address/Search bar. Basic web navigation monitoring.
    firefox_inspection = 64,
    // Monitor Internet Explorer event. Advanced web navigation monitoring.
    ie_monitoring = 128,
    // Inspect group membership of user. User identity monitoring.
    group_membership = 256,
};

template<> struct is_valid_enum_value<SessionProbeDisabledFeature>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 511; }
};

inline SessionProbeDisabledFeature operator | (SessionProbeDisabledFeature x, SessionProbeDisabledFeature y)
{
    return static_cast<SessionProbeDisabledFeature>(
        static_cast<uint16_t>(x) | static_cast<uint16_t>(y)
    );
}

inline SessionProbeDisabledFeature operator & (SessionProbeDisabledFeature x, SessionProbeDisabledFeature y)
{
    return static_cast<SessionProbeDisabledFeature>(
        static_cast<uint16_t>(x) & static_cast<uint16_t>(y)
    );
}

inline SessionProbeDisabledFeature operator ~ (SessionProbeDisabledFeature x)
{
    return static_cast<SessionProbeDisabledFeature>(
        ~static_cast<uint16_t>(x) & 511
    );
}

inline SessionProbeDisabledFeature & operator |= (SessionProbeDisabledFeature & x, SessionProbeDisabledFeature y) { return x = x | y; }
inline SessionProbeDisabledFeature & operator &= (SessionProbeDisabledFeature & x, SessionProbeDisabledFeature y) { return x = x & y; }

enum class RdpStoreFile : uint8_t
{
    // Never store transferred files.
    never = 0,
    // Always store transferred files.
    always = 1,
    // Transferred files are stored only if file verification is invalid. File verification by ICAP service must be enabled (in section file_verification).
    on_invalid_verification = 2,
};

template<> struct is_valid_enum_value<RdpStoreFile>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

// For targets running WALLIX BestSafe only.
enum class SessionProbeOnAccountManipulation : uint8_t
{
    // User action will be accepted.
    allow = 0,
    // (Same thing as 'allow'.)
    notify = 1,
    // User action will be rejected.
    deny = 2,
};

template<> struct is_valid_enum_value<SessionProbeOnAccountManipulation>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

// Client Address to send to target(in InfoPacket)
enum class ClientAddressSent : uint8_t
{
    // Send 0.0.0.0
    no_address = 0,
    // Send proxy client address or target connexion.
    proxy = 1,
    // Send user client address of front connexion.
    front = 2,
};

template<> struct is_valid_enum_value<ClientAddressSent>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

enum class SessionProbeLogLevel : uint8_t
{
    Off = 0,
    // Designates very severe error events that will presumably lead the application to abort.
    Fatal = 1,
    // Designates error events that might still allow the application to continue running.
    Error = 2,
    // Designates informational messages that highlight the progress of the application at coarse-grained level.
    Info = 3,
    // Designates potentially harmful situations.
    Warning = 4,
    // Designates fine-grained informational events that are mostly useful to debug an application.
    Debug = 5,
    // Designates finer-grained informational events than Debug.
    Detail = 6,
};

template<> struct is_valid_enum_value<SessionProbeLogLevel>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 6 && n != 0; }
};

enum class ModRdpUseFailureSimulationSocketTransport : uint8_t
{
    Off = 0,
    SimulateErrorRead = 1,
    SimulateErrorWrite = 2,
};

template<> struct is_valid_enum_value<ModRdpUseFailureSimulationSocketTransport>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

enum class LoginLanguage : uint8_t
{
    // The language is determined based on the keyboard layout specified by the client.
    Auto = 0,
    EN = 1,
    FR = 2,
};

template<> struct is_valid_enum_value<LoginLanguage>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

enum class VncTunnelingType : uint8_t
{
    pxssh = 0,
    pexpect = 1,
    popen = 2,
};

template<> struct is_valid_enum_value<VncTunnelingType>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

enum class VncTunnelingCredentialSource : uint8_t
{
    static_login = 0,
    scenario_account = 1,
};

template<> struct is_valid_enum_value<VncTunnelingCredentialSource>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 1; }
};

enum class BannerType : uint8_t
{
    info = 0,
    warn = 1,
    alert = 2,
};

template<> struct is_valid_enum_value<BannerType>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

enum class SessionProbeCPUUsageAlarmAction : uint8_t
{
    // Restart the Session Probe. May result in session disconnection due to loss of KeepAlive messages! Refer to 'On keepalive timeout' parameter of current section and 'Allow multiple handshakes' parameter of 'Configuration options'.
    Restart = 0,
    // Stop the Session Probe. May result in session disconnection due to loss of KeepAlive messages! Refer to 'On keepalive timeout' parameter of current section.
    Stop = 1,
};

template<> struct is_valid_enum_value<SessionProbeCPUUsageAlarmAction>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 1; }
};

enum class SessionProbeProcessCommandLineRetrieveMethod : uint8_t
{
    // Get command-line of processes via Windows Management Instrumentation. (Legacy method)
    windows_management_instrumentation = 0,
    // Calling internal system APIs to get the process command line. (More efficient but less stable)
    windows_internals = 1,
    // First use internal system APIs call, if that fails, use Windows Management Instrumentation method.
    both = 2,
};

template<> struct is_valid_enum_value<SessionProbeProcessCommandLineRetrieveMethod>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 2; }
};

enum class RdpSaveSessionInfoPDU : uint8_t
{
    // Windows
    Supported = 0,
    // Bastion, xrdp or others
    UnsupportedOrUnknown = 1,
};

template<> struct is_valid_enum_value<RdpSaveSessionInfoPDU>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 1; }
};

enum class SessionLogFormat : uint8_t
{
    disabled = 0,
    SIEM = 1,
    ArcSight = 2,
};

template<> struct is_valid_enum_value<SessionLogFormat>
{
    constexpr static bool is_valid(uint64_t n) { return n <= 3; }
};

inline SessionLogFormat operator | (SessionLogFormat x, SessionLogFormat y)
{
    return static_cast<SessionLogFormat>(
        static_cast<uint8_t>(x) | static_cast<uint8_t>(y)
    );
}

inline SessionLogFormat operator & (SessionLogFormat x, SessionLogFormat y)
{
    return static_cast<SessionLogFormat>(
        static_cast<uint8_t>(x) & static_cast<uint8_t>(y)
    );
}

inline SessionLogFormat operator ~ (SessionLogFormat x)
{
    return static_cast<SessionLogFormat>(
        ~static_cast<uint8_t>(x) & 3
    );
}

inline SessionLogFormat & operator |= (SessionLogFormat & x, SessionLogFormat y) { return x = x | y; }
inline SessionLogFormat & operator &= (SessionLogFormat & x, SessionLogFormat y) { return x = x & y; }

