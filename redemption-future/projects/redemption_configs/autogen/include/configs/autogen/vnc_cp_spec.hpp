//
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
//

R"xxxyyyzzz([general]

# Secondary login Transformation rule
# ${LOGIN} will be replaced by login
# ${DOMAIN} (optional) will be replaced by domain if it exists.
# Empty value means no transformation rule.
transformation_rule = string(default="")

# Account Mapping password retriever
# Transformation to apply to find the correct account.
# ${USER} will be replaced by the user's login.
# ${DOMAIN} will be replaced by the user's domain (in case of LDAP mapping).
# ${USER_DOMAIN} will be replaced by the user's login + "@" + user's domain (or just user's login if there's no domain).
# ${GROUP} will be replaced by the authorization's user group.
# ${DEVICE} will be replaced by the device's name.
# A regular expression is allowed to transform a variable, with the syntax: ${USER:/regex/replacement}, groups can be captured with parentheses and used with \1, \2, ...
# For example to replace leading "A" by "B" in the username: ${USER:/^A/B}
# Empty value means no transformation rule.
vault_transformation_rule = string(default="")

[session]

# No automatic disconnection due to inactivity, timer is set on target session.
# If the value is between 1 and 30, then 30 is used.
# If the value is set to 0, then the value set in "Base inactivity timeout" option (in "globals" section of "RDP Proxy" configuration option) is used.<br/>
# (in seconds)
inactivity_timeout = integer(min=0, default=0)

[all_target_mod]

# This parameter allows you to specify max timeout before a TCP connection is aborted. If the option value is specified as 0, TCP will use the system default.<br/>
# (in milliseconds)
#_advanced
#_display_name=TCP user timeout
tcp_user_timeout = integer(min=0, max=3600000, default=0)

[server_cert]

# Keep known target server certificates on Bastion
server_cert_store = boolean(default=True)

# Behavior of certificates check.
# &nbsp; &nbsp;   0: fails if certificates do not match or are missing.
# &nbsp; &nbsp;   1: fails if certificate does not match, succeeds if no known certificate.
# &nbsp; &nbsp;   2: succeeds if certificates exist (not checked), fails if missing.
# &nbsp; &nbsp;   3: always succeed.
# System errors like FS access rights issues or certificate decode are always check errors leading to connection rejection.
server_cert_check = option(0, 1, 2, 3, default=1)

# Warn if check allow connexion to target server.
# &nbsp; &nbsp;   0x0: nobody
# &nbsp; &nbsp;   0x1: SIEM: message sent to SIEM<br/>
# Note: values can be added (enable all: 0x1 = 0x1)
#_advanced
#_hex
server_access_allowed_message = integer(min=0, max=1, default=0)

# Warn that new target server certificate file was created.
# &nbsp; &nbsp;   0x0: nobody
# &nbsp; &nbsp;   0x1: SIEM: message sent to SIEM<br/>
# Note: values can be added (enable all: 0x1 = 0x1)
#_advanced
#_hex
server_cert_create_message = integer(min=0, max=1, default=1)

# Warn that target server certificate file was successfully checked.
# &nbsp; &nbsp;   0x0: nobody
# &nbsp; &nbsp;   0x1: SIEM: message sent to SIEM<br/>
# Note: values can be added (enable all: 0x1 = 0x1)
#_advanced
#_hex
server_cert_success_message = integer(min=0, max=1, default=0)

# Warn that target server certificate file checking failed.
# &nbsp; &nbsp;   0x0: nobody
# &nbsp; &nbsp;   0x1: SIEM: message sent to SIEM<br/>
# Note: values can be added (enable all: 0x1 = 0x1)
#_advanced
#_hex
server_cert_failure_message = integer(min=0, max=1, default=1)

[vnc]

support_cursor_pseudo_encoding = boolean(default=True)

#_display_name=Server is MacOS
server_is_macos = boolean(default=False)

# When disabled, Ctrl + Alt becomes AltGr (Windows behavior).
#_display_name=Server Unix alt
server_unix_alt = boolean(default=False)

# Enable target connection on IPv6.
#_display_name=Enable IPv6
enable_ipv6 = boolean(default=True)

# Minimal incoming TLS level 0=TLSv1, 1=TLSv1.1, 2=TLSv1.2, 3=TLSv1.3
#_display_name=TLS min level
tls_min_level = integer(min=0, default=2)

# Maximal incoming TLS level 0=no restriction, 1=TLSv1.1, 2=TLSv1.2, 3=TLSv1.3
#_display_name=TLS max level
tls_max_level = integer(min=0, default=0)

# TLSv1.2 and below additional ciphers supported.
# Empty to apply system-wide configuration (SSL security level 2), ALL for support of all ciphers to ensure highest compatibility with target servers.
# The format used is described on this page: https://www.openssl.org/docs/man3.1/man1/openssl-ciphers.html#CIPHER-LIST-FORMAT
cipher_string = string(default="ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES128-GCM-SHA256")

# Allow TLS legacy insecure renegotiation to unpatched target servers.
#_advanced
#_display_name=TLS enable legacy server
tls_enable_legacy_server = boolean(default=False)

# Configure the available TLSv1.3 ciphersuites.
# Empty to apply system-wide configuration.
# The format used is described in the third paragraph of this page: https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set_ciphersuites.html#DESCRIPTION
#_display_name=TLS 1.3 cipher suites
tls_1_3_ciphersuites = string(default="")

# Configure the supported key exchange groups.
# Empty to apply system-wide configuration.
# The format used is described in this page: https://www.openssl.org/docs/man3.2/man3/SSL_CONF_cmd.html#groups-groups
#_display_name=TLS key exchange groups
tls_key_exchange_groups = string(default="P-256:P-384:P-521:ffdhe3072:ffdhe4096:ffdhe6144:ffdhe8192")

# Show in the logs the common cipher list supported by client and target server.
# ⚠ Only for debugging purposes.
#_advanced
show_common_cipher_list = boolean(default=False)

# ⚠ The use of this feature is not recommended!<br/>
# When specified, force the proxy to use a specific authentication method. If this method is not supported by the target server, the connection will not be made.
# &nbsp; &nbsp;   - noauth
# &nbsp; &nbsp;   - vncauth
# &nbsp; &nbsp;   - mslogon
# &nbsp; &nbsp;   - mslogoniiauth
# &nbsp; &nbsp;   - ultravnc_dsm_old
# &nbsp; &nbsp;   - ultravnc_dsm_new
# &nbsp; &nbsp;   - tlsnone
# &nbsp; &nbsp;   - tlsvnc
# &nbsp; &nbsp;   - tlsplain
# &nbsp; &nbsp;   - x509none
# &nbsp; &nbsp;   - x509vnc
# &nbsp; &nbsp;   - x509plain
#_advanced
force_authentication_method = string(default="")

[capture]

# ⚠ Logs may contain passwords.<br/>
# Disable keyboard log:
# &nbsp; &nbsp;   0x0: none
# &nbsp; &nbsp;   0x1: disable keyboard log in session log
# &nbsp; &nbsp;   0x2: disable keyboard log in recorded sessions<br/>
# Note: values can be added (disable all: 0x1 + 0x2 = 0x3)
#_advanced
#_hex
disable_keyboard_log = integer(min=0, max=3, default=3)

[vnc_over_ssh]

enable = boolean(default=False)

# Port to be used for SSH tunneling
#_display_name=SSH port
ssh_port = integer(min=0, default=22)

# static_login: Static values provided in "SSH login" option &amp; "SSH password" option fields will be used to establish the SSH tunnel.
# scenario_account: Scenario account provided in "Scenario account name" option field will be used to establish the SSH tunnel. (Recommended)
tunneling_credential_source = option('static_login', 'scenario_account', default="scenario_account")

# Login to be used for SSH tunneling.
#_display_name=SSH login
ssh_login = string(default="")

# Password to be used for SSH tunneling.
#_display_name=SSH password
ssh_password = string(default="")

# With the following syntax: "account_name@domain_name[@[device_name]]".<br/>
# Syntax for using global domain scenario account:
# &nbsp; &nbsp;   "account_name@global_domain_name"<br/>
# Syntax for using local domain scenario account (with automatic device name deduction):
# &nbsp; &nbsp;   "account_name@local_domain_name@"
scenario_account_name = string(default="")

# Only for debugging purposes.
#_advanced
tunneling_type = option('pxssh', 'pexpect', 'popen', default="pxssh")

)xxxyyyzzz"
