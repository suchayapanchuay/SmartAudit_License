// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

namespace
{

inline constexpr zstring_view enum_zstr_ModuleName[] {
    "UNKNOWN"_zv,
    "login"_zv,
    "selector"_zv,
    "confirm"_zv,
    "link_confirm"_zv,
    "challenge"_zv,
    "valid"_zv,
    "transitory"_zv,
    "close"_zv,
    "close_back"_zv,
    "interactive_target"_zv,
    "RDP"_zv,
    "VNC"_zv,
    "INTERNAL"_zv,
    "waitinfo"_zv,
    "bouncer2"_zv,
    "autotest"_zv,
    "widgettest"_zv,
    "card"_zv,
};

inline constexpr zstring_view enum_zint_ModuleName[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
    "3"_zv,
    "4"_zv,
    "5"_zv,
    "6"_zv,
    "7"_zv,
    "8"_zv,
    "9"_zv,
    "10"_zv,
    "11"_zv,
    "12"_zv,
    "13"_zv,
    "14"_zv,
    "15"_zv,
    "16"_zv,
    "17"_zv,
    "18"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<ModuleName> /*type*/,
    ModuleName x
){
    (void)zbuf;
    assert(is_valid_enum_value<ModuleName>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_ModuleName[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    ModuleName x
){
    (void)zbuf;
    assert(is_valid_enum_value<ModuleName>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_ModuleName[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(ModuleName & x, ::configs::spec_type<ModuleName> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 18>()
    )) {
        return err;
    }

    x = static_cast<ModuleName>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, ModuleName> enum_str_value_ModuleName[] {
    {"UNKNOWN"_av, ModuleName::UNKNOWN},
    {"LOGIN"_av, ModuleName::login},
    {"SELECTOR"_av, ModuleName::selector},
    {"CONFIRM"_av, ModuleName::confirm},
    {"LINK_CONFIRM"_av, ModuleName::link_confirm},
    {"CHALLENGE"_av, ModuleName::challenge},
    {"VALID"_av, ModuleName::valid},
    {"TRANSITORY"_av, ModuleName::transitory},
    {"CLOSE"_av, ModuleName::close},
    {"CLOSE_BACK"_av, ModuleName::close_back},
    {"INTERACTIVE_TARGET"_av, ModuleName::interactive_target},
    {"RDP"_av, ModuleName::RDP},
    {"VNC"_av, ModuleName::VNC},
    {"INTERNAL"_av, ModuleName::INTERNAL},
    {"WAITINFO"_av, ModuleName::waitinfo},
    {"BOUNCER2"_av, ModuleName::bouncer2},
    {"AUTOTEST"_av, ModuleName::autotest},
    {"WIDGETTEST"_av, ModuleName::widgettest},
    {"CARD"_av, ModuleName::card},
};

parse_error parse_from_cfg(ModuleName & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_ModuleName>(
        x, value, "bad value, expected: UNKNOWN, login, selector, confirm, link_confirm, challenge, valid, transitory, close, close_back, interactive_target, RDP, VNC, INTERNAL, waitinfo, bouncer2, autotest, widgettest, card");
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<CaptureFlags> /*type*/,
    CaptureFlags x
){
    auto r = std::to_chars(zbuf.begin(), zbuf.end(), static_cast<uint8_t>(x));
    *r.ptr = '\0';
    return zstring_view::from_null_terminated({zbuf.data(), r.ptr});
}

parse_error parse_from_cfg(CaptureFlags & x, ::configs::spec_type<CaptureFlags> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 15>()
    )) {
        return err;
    }

    x = static_cast<CaptureFlags>(xi);
    return no_parse_error;
}

inline constexpr zstring_view enum_zstr_RdpSecurityEncryptionLevel[] {
    "none"_zv,
    "low"_zv,
    "medium"_zv,
    "high"_zv,
};

inline constexpr zstring_view enum_zint_RdpSecurityEncryptionLevel[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
    "3"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<RdpSecurityEncryptionLevel> /*type*/,
    RdpSecurityEncryptionLevel x
){
    (void)zbuf;
    assert(is_valid_enum_value<RdpSecurityEncryptionLevel>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_RdpSecurityEncryptionLevel[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    RdpSecurityEncryptionLevel x
){
    (void)zbuf;
    assert(is_valid_enum_value<RdpSecurityEncryptionLevel>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_RdpSecurityEncryptionLevel[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(RdpSecurityEncryptionLevel & x, ::configs::spec_type<RdpSecurityEncryptionLevel> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 3>()
    )) {
        return err;
    }

    x = static_cast<RdpSecurityEncryptionLevel>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, RdpSecurityEncryptionLevel> enum_str_value_RdpSecurityEncryptionLevel[] {
    {"NONE"_av, RdpSecurityEncryptionLevel::none},
    {"LOW"_av, RdpSecurityEncryptionLevel::low},
    {"MEDIUM"_av, RdpSecurityEncryptionLevel::medium},
    {"HIGH"_av, RdpSecurityEncryptionLevel::high},
};

parse_error parse_from_cfg(RdpSecurityEncryptionLevel & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_RdpSecurityEncryptionLevel>(
        x, value, "bad value, expected: none, low, medium, high");
}

inline constexpr zstring_view enum_zstr_Language[] {
    "en"_zv,
    "fr"_zv,
};

inline constexpr zstring_view enum_zint_Language[] {
    "0"_zv,
    "1"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<Language> /*type*/,
    Language x
){
    (void)zbuf;
    assert(is_valid_enum_value<Language>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_Language[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    Language x
){
    (void)zbuf;
    assert(is_valid_enum_value<Language>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_Language[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(Language & x, ::configs::spec_type<Language> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 1>()
    )) {
        return err;
    }

    x = static_cast<Language>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, Language> enum_str_value_Language[] {
    {"EN"_av, Language::en},
    {"FR"_av, Language::fr},
};

parse_error parse_from_cfg(Language & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_Language>(
        x, value, "bad value, expected: en, fr");
}

inline constexpr zstring_view enum_zstr_ClipboardEncodingType[] {
    "utf-8"_zv,
    "latin1"_zv,
};

inline constexpr zstring_view enum_zint_ClipboardEncodingType[] {
    "0"_zv,
    "1"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<ClipboardEncodingType> /*type*/,
    ClipboardEncodingType x
){
    (void)zbuf;
    assert(is_valid_enum_value<ClipboardEncodingType>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_ClipboardEncodingType[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    ClipboardEncodingType x
){
    (void)zbuf;
    assert(is_valid_enum_value<ClipboardEncodingType>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_ClipboardEncodingType[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(ClipboardEncodingType & x, ::configs::spec_type<ClipboardEncodingType> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 1>()
    )) {
        return err;
    }

    x = static_cast<ClipboardEncodingType>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, ClipboardEncodingType> enum_str_value_ClipboardEncodingType[] {
    {"UTF-8"_av, ClipboardEncodingType::utf8},
    {"LATIN1"_av, ClipboardEncodingType::latin1},
};

parse_error parse_from_cfg(ClipboardEncodingType & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_ClipboardEncodingType>(
        x, value, "bad value, expected: utf-8, latin1");
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<KeyboardLogFlags> /*type*/,
    KeyboardLogFlags x
){
    auto r = std::to_chars(zbuf.begin(), zbuf.end(), static_cast<uint8_t>(x));
    *r.ptr = '\0';
    return zstring_view::from_null_terminated({zbuf.data(), r.ptr});
}

parse_error parse_from_cfg(KeyboardLogFlags & x, ::configs::spec_type<KeyboardLogFlags> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 3>()
    )) {
        return err;
    }

    x = static_cast<KeyboardLogFlags>(xi);
    return no_parse_error;
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<ClipboardLogFlags> /*type*/,
    ClipboardLogFlags x
){
    auto r = std::to_chars(zbuf.begin(), zbuf.end(), static_cast<uint8_t>(x));
    *r.ptr = '\0';
    return zstring_view::from_null_terminated({zbuf.data(), r.ptr});
}

parse_error parse_from_cfg(ClipboardLogFlags & x, ::configs::spec_type<ClipboardLogFlags> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 3>()
    )) {
        return err;
    }

    x = static_cast<ClipboardLogFlags>(xi);
    return no_parse_error;
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<FileSystemLogFlags> /*type*/,
    FileSystemLogFlags x
){
    auto r = std::to_chars(zbuf.begin(), zbuf.end(), static_cast<uint8_t>(x));
    *r.ptr = '\0';
    return zstring_view::from_null_terminated({zbuf.data(), r.ptr});
}

parse_error parse_from_cfg(FileSystemLogFlags & x, ::configs::spec_type<FileSystemLogFlags> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 3>()
    )) {
        return err;
    }

    x = static_cast<FileSystemLogFlags>(xi);
    return no_parse_error;
}

inline constexpr zstring_view enum_zstr_ColorDepth[] {
    "depth8"_zv,
    "depth15"_zv,
    "depth16"_zv,
    "depth24"_zv,
    "depth32"_zv,
};

inline constexpr zstring_view enum_zint_ColorDepth[] {
    "8"_zv,
    "15"_zv,
    "16"_zv,
    "24"_zv,
    "32"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<ColorDepth> /*type*/,
    ColorDepth x
){
    (void)zbuf;
    switch (x) {
        case ColorDepth::depth8: return enum_zint_ColorDepth[0];
        case ColorDepth::depth15: return enum_zint_ColorDepth[1];
        case ColorDepth::depth16: return enum_zint_ColorDepth[2];
        case ColorDepth::depth24: return enum_zint_ColorDepth[3];
        case ColorDepth::depth32: return enum_zint_ColorDepth[4];
    }
    assert(!"unknown value");
    return ""_zv;
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    ColorDepth x
){
    (void)zbuf;
    switch (x) {
        case ColorDepth::depth8: return enum_zstr_ColorDepth[0];
        case ColorDepth::depth15: return enum_zstr_ColorDepth[1];
        case ColorDepth::depth16: return enum_zstr_ColorDepth[2];
        case ColorDepth::depth24: return enum_zstr_ColorDepth[3];
        case ColorDepth::depth32: return enum_zstr_ColorDepth[4];
    }
    assert(!"unknown value");
    return ""_zv;
}

parse_error parse_from_cfg(ColorDepth & x, ::configs::spec_type<ColorDepth> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        min_integral<ul>(),
        max_integral<ul>()
    )) {
        return err;
    }

    switch (xi) {
        case static_cast<uint8_t>(ColorDepth::depth8):
        case static_cast<uint8_t>(ColorDepth::depth15):
        case static_cast<uint8_t>(ColorDepth::depth16):
        case static_cast<uint8_t>(ColorDepth::depth24):
        case static_cast<uint8_t>(ColorDepth::depth32):
               break;
        default: return parse_error{"unknown value"};
    }

    x = static_cast<ColorDepth>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, ColorDepth> enum_str_value_ColorDepth[] {
    {"DEPTH8"_av, ColorDepth::depth8},
    {"DEPTH15"_av, ColorDepth::depth15},
    {"DEPTH16"_av, ColorDepth::depth16},
    {"DEPTH24"_av, ColorDepth::depth24},
    {"DEPTH32"_av, ColorDepth::depth32},
};

parse_error parse_from_cfg(ColorDepth & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_ColorDepth>(
        x, value, "bad value, expected: depth8, depth15, depth16, depth24, depth32");
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<ServerCertNotification> /*type*/,
    ServerCertNotification x
){
    auto r = std::to_chars(zbuf.begin(), zbuf.end(), static_cast<uint8_t>(x));
    *r.ptr = '\0';
    return zstring_view::from_null_terminated({zbuf.data(), r.ptr});
}

parse_error parse_from_cfg(ServerCertNotification & x, ::configs::spec_type<ServerCertNotification> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 1>()
    )) {
        return err;
    }

    x = static_cast<ServerCertNotification>(xi);
    return no_parse_error;
}

inline constexpr zstring_view enum_zstr_ServerCertCheck[] {
    "fails_if_no_match_or_missing"_zv,
    "fails_if_no_match_and_succeed_if_no_know"_zv,
    "succeed_if_exists_and_fails_if_missing"_zv,
    "always_succeed"_zv,
};

inline constexpr zstring_view enum_zint_ServerCertCheck[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
    "3"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<ServerCertCheck> /*type*/,
    ServerCertCheck x
){
    (void)zbuf;
    assert(is_valid_enum_value<ServerCertCheck>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_ServerCertCheck[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    ServerCertCheck x
){
    (void)zbuf;
    assert(is_valid_enum_value<ServerCertCheck>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_ServerCertCheck[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(ServerCertCheck & x, ::configs::spec_type<ServerCertCheck> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 3>()
    )) {
        return err;
    }

    x = static_cast<ServerCertCheck>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, ServerCertCheck> enum_str_value_ServerCertCheck[] {
    {"FAILS_IF_NO_MATCH_OR_MISSING"_av, ServerCertCheck::fails_if_no_match_or_missing},
    {"FAILS_IF_NO_MATCH_AND_SUCCEED_IF_NO_KNOW"_av, ServerCertCheck::fails_if_no_match_and_succeed_if_no_know},
    {"SUCCEED_IF_EXISTS_AND_FAILS_IF_MISSING"_av, ServerCertCheck::succeed_if_exists_and_fails_if_missing},
    {"ALWAYS_SUCCEED"_av, ServerCertCheck::always_succeed},
};

parse_error parse_from_cfg(ServerCertCheck & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_ServerCertCheck>(
        x, value, "bad value, expected: fails_if_no_match_or_missing, fails_if_no_match_and_succeed_if_no_know, succeed_if_exists_and_fails_if_missing, always_succeed");
}

inline constexpr zstring_view enum_zstr_TraceType[] {
    "localfile"_zv,
    "localfile_hashed"_zv,
    "cryptofile"_zv,
};

inline constexpr zstring_view enum_zint_TraceType[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<TraceType> /*type*/,
    TraceType x
){
    (void)zbuf;
    assert(is_valid_enum_value<TraceType>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_TraceType[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    TraceType x
){
    (void)zbuf;
    assert(is_valid_enum_value<TraceType>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_TraceType[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(TraceType & x, ::configs::spec_type<TraceType> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<TraceType>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, TraceType> enum_str_value_TraceType[] {
    {"LOCALFILE"_av, TraceType::localfile},
    {"LOCALFILE_HASHED"_av, TraceType::localfile_hashed},
    {"CRYPTOFILE"_av, TraceType::cryptofile},
};

parse_error parse_from_cfg(TraceType & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_TraceType>(
        x, value, "bad value, expected: localfile, localfile_hashed, cryptofile");
}

inline constexpr zstring_view enum_zstr_KeyboardInputMaskingLevel[] {
    "unmasked"_zv,
    "password_only"_zv,
    "password_and_unidentified"_zv,
    "fully_masked"_zv,
};

inline constexpr zstring_view enum_zint_KeyboardInputMaskingLevel[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
    "3"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<KeyboardInputMaskingLevel> /*type*/,
    KeyboardInputMaskingLevel x
){
    (void)zbuf;
    assert(is_valid_enum_value<KeyboardInputMaskingLevel>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_KeyboardInputMaskingLevel[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    KeyboardInputMaskingLevel x
){
    (void)zbuf;
    assert(is_valid_enum_value<KeyboardInputMaskingLevel>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_KeyboardInputMaskingLevel[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(KeyboardInputMaskingLevel & x, ::configs::spec_type<KeyboardInputMaskingLevel> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 3>()
    )) {
        return err;
    }

    x = static_cast<KeyboardInputMaskingLevel>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, KeyboardInputMaskingLevel> enum_str_value_KeyboardInputMaskingLevel[] {
    {"UNMASKED"_av, KeyboardInputMaskingLevel::unmasked},
    {"PASSWORD_ONLY"_av, KeyboardInputMaskingLevel::password_only},
    {"PASSWORD_AND_UNIDENTIFIED"_av, KeyboardInputMaskingLevel::password_and_unidentified},
    {"FULLY_MASKED"_av, KeyboardInputMaskingLevel::fully_masked},
};

parse_error parse_from_cfg(KeyboardInputMaskingLevel & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_KeyboardInputMaskingLevel>(
        x, value, "bad value, expected: unmasked, password_only, password_and_unidentified, fully_masked");
}

inline constexpr zstring_view enum_zstr_SessionProbeOnLaunchFailure[] {
    "ignore_and_continue"_zv,
    "disconnect_user"_zv,
    "retry_without_session_probe"_zv,
};

inline constexpr zstring_view enum_zint_SessionProbeOnLaunchFailure[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<SessionProbeOnLaunchFailure> /*type*/,
    SessionProbeOnLaunchFailure x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeOnLaunchFailure>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_SessionProbeOnLaunchFailure[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    SessionProbeOnLaunchFailure x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeOnLaunchFailure>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_SessionProbeOnLaunchFailure[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(SessionProbeOnLaunchFailure & x, ::configs::spec_type<SessionProbeOnLaunchFailure> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<SessionProbeOnLaunchFailure>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, SessionProbeOnLaunchFailure> enum_str_value_SessionProbeOnLaunchFailure[] {
    {"IGNORE_AND_CONTINUE"_av, SessionProbeOnLaunchFailure::ignore_and_continue},
    {"DISCONNECT_USER"_av, SessionProbeOnLaunchFailure::disconnect_user},
    {"RETRY_WITHOUT_SESSION_PROBE"_av, SessionProbeOnLaunchFailure::retry_without_session_probe},
};

parse_error parse_from_cfg(SessionProbeOnLaunchFailure & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_SessionProbeOnLaunchFailure>(
        x, value, "bad value, expected: ignore_and_continue, disconnect_user, retry_without_session_probe");
}

inline constexpr zstring_view enum_zstr_VncBogusClipboardInfiniteLoop[] {
    "delayed"_zv,
    "duplicated"_zv,
    "continued"_zv,
};

inline constexpr zstring_view enum_zint_VncBogusClipboardInfiniteLoop[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<VncBogusClipboardInfiniteLoop> /*type*/,
    VncBogusClipboardInfiniteLoop x
){
    (void)zbuf;
    assert(is_valid_enum_value<VncBogusClipboardInfiniteLoop>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_VncBogusClipboardInfiniteLoop[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    VncBogusClipboardInfiniteLoop x
){
    (void)zbuf;
    assert(is_valid_enum_value<VncBogusClipboardInfiniteLoop>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_VncBogusClipboardInfiniteLoop[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(VncBogusClipboardInfiniteLoop & x, ::configs::spec_type<VncBogusClipboardInfiniteLoop> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<VncBogusClipboardInfiniteLoop>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, VncBogusClipboardInfiniteLoop> enum_str_value_VncBogusClipboardInfiniteLoop[] {
    {"DELAYED"_av, VncBogusClipboardInfiniteLoop::delayed},
    {"DUPLICATED"_av, VncBogusClipboardInfiniteLoop::duplicated},
    {"CONTINUED"_av, VncBogusClipboardInfiniteLoop::continued},
};

parse_error parse_from_cfg(VncBogusClipboardInfiniteLoop & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_VncBogusClipboardInfiniteLoop>(
        x, value, "bad value, expected: delayed, duplicated, continued");
}

inline constexpr zstring_view enum_zstr_ColorDepthSelectionStrategy[] {
    "depth24"_zv,
    "depth16"_zv,
};

inline constexpr zstring_view enum_zint_ColorDepthSelectionStrategy[] {
    "0"_zv,
    "1"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<ColorDepthSelectionStrategy> /*type*/,
    ColorDepthSelectionStrategy x
){
    (void)zbuf;
    assert(is_valid_enum_value<ColorDepthSelectionStrategy>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_ColorDepthSelectionStrategy[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    ColorDepthSelectionStrategy x
){
    (void)zbuf;
    assert(is_valid_enum_value<ColorDepthSelectionStrategy>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_ColorDepthSelectionStrategy[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(ColorDepthSelectionStrategy & x, ::configs::spec_type<ColorDepthSelectionStrategy> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 1>()
    )) {
        return err;
    }

    x = static_cast<ColorDepthSelectionStrategy>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, ColorDepthSelectionStrategy> enum_str_value_ColorDepthSelectionStrategy[] {
    {"DEPTH24"_av, ColorDepthSelectionStrategy::depth24},
    {"DEPTH16"_av, ColorDepthSelectionStrategy::depth16},
};

parse_error parse_from_cfg(ColorDepthSelectionStrategy & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_ColorDepthSelectionStrategy>(
        x, value, "bad value, expected: depth24, depth16");
}

inline constexpr zstring_view enum_zstr_WrmCompressionAlgorithm[] {
    "no_compression"_zv,
    "gzip"_zv,
    "snappy"_zv,
};

inline constexpr zstring_view enum_zint_WrmCompressionAlgorithm[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<WrmCompressionAlgorithm> /*type*/,
    WrmCompressionAlgorithm x
){
    (void)zbuf;
    assert(is_valid_enum_value<WrmCompressionAlgorithm>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_WrmCompressionAlgorithm[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    WrmCompressionAlgorithm x
){
    (void)zbuf;
    assert(is_valid_enum_value<WrmCompressionAlgorithm>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_WrmCompressionAlgorithm[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(WrmCompressionAlgorithm & x, ::configs::spec_type<WrmCompressionAlgorithm> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<WrmCompressionAlgorithm>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, WrmCompressionAlgorithm> enum_str_value_WrmCompressionAlgorithm[] {
    {"NO_COMPRESSION"_av, WrmCompressionAlgorithm::no_compression},
    {"GZIP"_av, WrmCompressionAlgorithm::gzip},
    {"SNAPPY"_av, WrmCompressionAlgorithm::snappy},
};

parse_error parse_from_cfg(WrmCompressionAlgorithm & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_WrmCompressionAlgorithm>(
        x, value, "bad value, expected: no_compression, gzip, snappy");
}

inline constexpr zstring_view enum_zstr_RdpCompression[] {
    "none"_zv,
    "rdp4"_zv,
    "rdp5"_zv,
    "rdp6"_zv,
    "rdp6_1"_zv,
};

inline constexpr zstring_view enum_zint_RdpCompression[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
    "3"_zv,
    "4"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<RdpCompression> /*type*/,
    RdpCompression x
){
    (void)zbuf;
    assert(is_valid_enum_value<RdpCompression>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_RdpCompression[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    RdpCompression x
){
    (void)zbuf;
    assert(is_valid_enum_value<RdpCompression>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_RdpCompression[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(RdpCompression & x, ::configs::spec_type<RdpCompression> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 4>()
    )) {
        return err;
    }

    x = static_cast<RdpCompression>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, RdpCompression> enum_str_value_RdpCompression[] {
    {"NONE"_av, RdpCompression::none},
    {"RDP4"_av, RdpCompression::rdp4},
    {"RDP5"_av, RdpCompression::rdp5},
    {"RDP6"_av, RdpCompression::rdp6},
    {"RDP6_1"_av, RdpCompression::rdp6_1},
};

parse_error parse_from_cfg(RdpCompression & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_RdpCompression>(
        x, value, "bad value, expected: none, rdp4, rdp5, rdp6, rdp6_1");
}

inline constexpr zstring_view enum_zstr_OcrVersion[] {
    "v1"_zv,
    "v2"_zv,
};

inline constexpr zstring_view enum_zint_OcrVersion[] {
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<OcrVersion> /*type*/,
    OcrVersion x
){
    (void)zbuf;
    switch (x) {
        case OcrVersion::v1: return enum_zint_OcrVersion[0];
        case OcrVersion::v2: return enum_zint_OcrVersion[1];
    }
    assert(!"unknown value");
    return ""_zv;
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    OcrVersion x
){
    (void)zbuf;
    switch (x) {
        case OcrVersion::v1: return enum_zstr_OcrVersion[0];
        case OcrVersion::v2: return enum_zstr_OcrVersion[1];
    }
    assert(!"unknown value");
    return ""_zv;
}

parse_error parse_from_cfg(OcrVersion & x, ::configs::spec_type<OcrVersion> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        min_integral<ul>(),
        max_integral<ul>()
    )) {
        return err;
    }

    switch (xi) {
        case static_cast<uint8_t>(OcrVersion::v1):
        case static_cast<uint8_t>(OcrVersion::v2):
               break;
        default: return parse_error{"unknown value"};
    }

    x = static_cast<OcrVersion>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, OcrVersion> enum_str_value_OcrVersion[] {
    {"V1"_av, OcrVersion::v1},
    {"V2"_av, OcrVersion::v2},
};

parse_error parse_from_cfg(OcrVersion & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_OcrVersion>(
        x, value, "bad value, expected: v1, v2");
}

inline constexpr zstring_view enum_zstr_OcrLocale[] {
    "latin"_zv,
    "cyrillic"_zv,
};

inline constexpr zstring_view enum_zint_OcrLocale[] {
    "0"_zv,
    "1"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<OcrLocale> /*type*/,
    OcrLocale x
){
    (void)zbuf;
    assert(is_valid_enum_value<OcrLocale>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_OcrLocale[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    OcrLocale x
){
    (void)zbuf;
    assert(is_valid_enum_value<OcrLocale>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_OcrLocale[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(OcrLocale & x, ::configs::spec_type<OcrLocale> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 1>()
    )) {
        return err;
    }

    x = static_cast<OcrLocale>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, OcrLocale> enum_str_value_OcrLocale[] {
    {"LATIN"_av, OcrLocale::latin},
    {"CYRILLIC"_av, OcrLocale::cyrillic},
};

parse_error parse_from_cfg(OcrLocale & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_OcrLocale>(
        x, value, "bad value, expected: latin, cyrillic");
}

inline constexpr zstring_view enum_zstr_SessionProbeOnKeepaliveTimeout[] {
    "ignore_and_continue"_zv,
    "disconnect_user"_zv,
    "freeze_connection_and_wait"_zv,
};

inline constexpr zstring_view enum_zint_SessionProbeOnKeepaliveTimeout[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<SessionProbeOnKeepaliveTimeout> /*type*/,
    SessionProbeOnKeepaliveTimeout x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeOnKeepaliveTimeout>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_SessionProbeOnKeepaliveTimeout[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    SessionProbeOnKeepaliveTimeout x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeOnKeepaliveTimeout>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_SessionProbeOnKeepaliveTimeout[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(SessionProbeOnKeepaliveTimeout & x, ::configs::spec_type<SessionProbeOnKeepaliveTimeout> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<SessionProbeOnKeepaliveTimeout>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, SessionProbeOnKeepaliveTimeout> enum_str_value_SessionProbeOnKeepaliveTimeout[] {
    {"IGNORE_AND_CONTINUE"_av, SessionProbeOnKeepaliveTimeout::ignore_and_continue},
    {"DISCONNECT_USER"_av, SessionProbeOnKeepaliveTimeout::disconnect_user},
    {"FREEZE_CONNECTION_AND_WAIT"_av, SessionProbeOnKeepaliveTimeout::freeze_connection_and_wait},
};

parse_error parse_from_cfg(SessionProbeOnKeepaliveTimeout & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_SessionProbeOnKeepaliveTimeout>(
        x, value, "bad value, expected: ignore_and_continue, disconnect_user, freeze_connection_and_wait");
}

inline constexpr zstring_view enum_zstr_SmartVideoCropping[] {
    "disable"_zv,
    "v1"_zv,
    "v2"_zv,
};

inline constexpr zstring_view enum_zint_SmartVideoCropping[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<SmartVideoCropping> /*type*/,
    SmartVideoCropping x
){
    (void)zbuf;
    assert(is_valid_enum_value<SmartVideoCropping>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_SmartVideoCropping[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    SmartVideoCropping x
){
    (void)zbuf;
    assert(is_valid_enum_value<SmartVideoCropping>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_SmartVideoCropping[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(SmartVideoCropping & x, ::configs::spec_type<SmartVideoCropping> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<SmartVideoCropping>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, SmartVideoCropping> enum_str_value_SmartVideoCropping[] {
    {"DISABLE"_av, SmartVideoCropping::disable},
    {"V1"_av, SmartVideoCropping::v1},
    {"V2"_av, SmartVideoCropping::v2},
};

parse_error parse_from_cfg(SmartVideoCropping & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_SmartVideoCropping>(
        x, value, "bad value, expected: disable, v1, v2");
}

inline constexpr zstring_view enum_zstr_RdpModeConsole[] {
    "allow"_zv,
    "force"_zv,
    "forbid"_zv,
};

inline constexpr zstring_view enum_zint_RdpModeConsole[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<RdpModeConsole> /*type*/,
    RdpModeConsole x
){
    (void)zbuf;
    assert(is_valid_enum_value<RdpModeConsole>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_RdpModeConsole[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    RdpModeConsole x
){
    (void)zbuf;
    assert(is_valid_enum_value<RdpModeConsole>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_RdpModeConsole[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(RdpModeConsole & x, ::configs::spec_type<RdpModeConsole> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<RdpModeConsole>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, RdpModeConsole> enum_str_value_RdpModeConsole[] {
    {"ALLOW"_av, RdpModeConsole::allow},
    {"FORCE"_av, RdpModeConsole::force},
    {"FORBID"_av, RdpModeConsole::forbid},
};

parse_error parse_from_cfg(RdpModeConsole & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_RdpModeConsole>(
        x, value, "bad value, expected: allow, force, forbid");
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<SessionProbeDisabledFeature> /*type*/,
    SessionProbeDisabledFeature x
){
    auto r = std::to_chars(zbuf.begin(), zbuf.end(), static_cast<uint16_t>(x));
    *r.ptr = '\0';
    return zstring_view::from_null_terminated({zbuf.data(), r.ptr});
}

parse_error parse_from_cfg(SessionProbeDisabledFeature & x, ::configs::spec_type<SessionProbeDisabledFeature> /*type*/, bytes_view value)
{
    using ul = uint16_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 511>()
    )) {
        return err;
    }

    x = static_cast<SessionProbeDisabledFeature>(xi);
    return no_parse_error;
}

inline constexpr zstring_view enum_zstr_RdpStoreFile[] {
    "never"_zv,
    "always"_zv,
    "on_invalid_verification"_zv,
};

inline constexpr zstring_view enum_zint_RdpStoreFile[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<RdpStoreFile> /*type*/,
    RdpStoreFile x
){
    (void)zbuf;
    assert(is_valid_enum_value<RdpStoreFile>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_RdpStoreFile[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    RdpStoreFile x
){
    (void)zbuf;
    assert(is_valid_enum_value<RdpStoreFile>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_RdpStoreFile[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(RdpStoreFile & x, ::configs::spec_type<RdpStoreFile> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<RdpStoreFile>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, RdpStoreFile> enum_str_value_RdpStoreFile[] {
    {"NEVER"_av, RdpStoreFile::never},
    {"ALWAYS"_av, RdpStoreFile::always},
    {"ON_INVALID_VERIFICATION"_av, RdpStoreFile::on_invalid_verification},
};

parse_error parse_from_cfg(RdpStoreFile & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_RdpStoreFile>(
        x, value, "bad value, expected: never, always, on_invalid_verification");
}

inline constexpr zstring_view enum_zstr_SessionProbeOnAccountManipulation[] {
    "allow"_zv,
    "notify"_zv,
    "deny"_zv,
};

inline constexpr zstring_view enum_zint_SessionProbeOnAccountManipulation[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<SessionProbeOnAccountManipulation> /*type*/,
    SessionProbeOnAccountManipulation x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeOnAccountManipulation>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_SessionProbeOnAccountManipulation[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    SessionProbeOnAccountManipulation x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeOnAccountManipulation>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_SessionProbeOnAccountManipulation[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(SessionProbeOnAccountManipulation & x, ::configs::spec_type<SessionProbeOnAccountManipulation> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<SessionProbeOnAccountManipulation>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, SessionProbeOnAccountManipulation> enum_str_value_SessionProbeOnAccountManipulation[] {
    {"ALLOW"_av, SessionProbeOnAccountManipulation::allow},
    {"NOTIFY"_av, SessionProbeOnAccountManipulation::notify},
    {"DENY"_av, SessionProbeOnAccountManipulation::deny},
};

parse_error parse_from_cfg(SessionProbeOnAccountManipulation & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_SessionProbeOnAccountManipulation>(
        x, value, "bad value, expected: allow, notify, deny");
}

inline constexpr zstring_view enum_zstr_ClientAddressSent[] {
    "no_address"_zv,
    "proxy"_zv,
    "front"_zv,
};

inline constexpr zstring_view enum_zint_ClientAddressSent[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<ClientAddressSent> /*type*/,
    ClientAddressSent x
){
    (void)zbuf;
    assert(is_valid_enum_value<ClientAddressSent>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_ClientAddressSent[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    ClientAddressSent x
){
    (void)zbuf;
    assert(is_valid_enum_value<ClientAddressSent>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_ClientAddressSent[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(ClientAddressSent & x, ::configs::spec_type<ClientAddressSent> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<ClientAddressSent>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, ClientAddressSent> enum_str_value_ClientAddressSent[] {
    {"NO_ADDRESS"_av, ClientAddressSent::no_address},
    {"PROXY"_av, ClientAddressSent::proxy},
    {"FRONT"_av, ClientAddressSent::front},
};

parse_error parse_from_cfg(ClientAddressSent & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_ClientAddressSent>(
        x, value, "bad value, expected: no_address, proxy, front");
}

inline constexpr zstring_view enum_zstr_SessionProbeLogLevel[] {
    "Off"_zv,
    "Fatal"_zv,
    "Error"_zv,
    "Info"_zv,
    "Warning"_zv,
    "Debug"_zv,
    "Detail"_zv,
};

inline constexpr zstring_view enum_zint_SessionProbeLogLevel[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
    "3"_zv,
    "4"_zv,
    "5"_zv,
    "6"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<SessionProbeLogLevel> /*type*/,
    SessionProbeLogLevel x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeLogLevel>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_SessionProbeLogLevel[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    SessionProbeLogLevel x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeLogLevel>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_SessionProbeLogLevel[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(SessionProbeLogLevel & x, ::configs::spec_type<SessionProbeLogLevel> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 6>()
    )) {
        return err;
    }

    x = static_cast<SessionProbeLogLevel>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, SessionProbeLogLevel> enum_str_value_SessionProbeLogLevel[] {
    {"OFF"_av, SessionProbeLogLevel::Off},
    {"FATAL"_av, SessionProbeLogLevel::Fatal},
    {"ERROR"_av, SessionProbeLogLevel::Error},
    {"INFO"_av, SessionProbeLogLevel::Info},
    {"WARNING"_av, SessionProbeLogLevel::Warning},
    {"DEBUG"_av, SessionProbeLogLevel::Debug},
    {"DETAIL"_av, SessionProbeLogLevel::Detail},
};

parse_error parse_from_cfg(SessionProbeLogLevel & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_SessionProbeLogLevel>(
        x, value, "bad value, expected: Off, Fatal, Error, Info, Warning, Debug, Detail");
}

inline constexpr zstring_view enum_zstr_ModRdpUseFailureSimulationSocketTransport[] {
    "Off"_zv,
    "SimulateErrorRead"_zv,
    "SimulateErrorWrite"_zv,
};

inline constexpr zstring_view enum_zint_ModRdpUseFailureSimulationSocketTransport[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<ModRdpUseFailureSimulationSocketTransport> /*type*/,
    ModRdpUseFailureSimulationSocketTransport x
){
    (void)zbuf;
    assert(is_valid_enum_value<ModRdpUseFailureSimulationSocketTransport>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_ModRdpUseFailureSimulationSocketTransport[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    ModRdpUseFailureSimulationSocketTransport x
){
    (void)zbuf;
    assert(is_valid_enum_value<ModRdpUseFailureSimulationSocketTransport>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_ModRdpUseFailureSimulationSocketTransport[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(ModRdpUseFailureSimulationSocketTransport & x, ::configs::spec_type<ModRdpUseFailureSimulationSocketTransport> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<ModRdpUseFailureSimulationSocketTransport>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, ModRdpUseFailureSimulationSocketTransport> enum_str_value_ModRdpUseFailureSimulationSocketTransport[] {
    {"OFF"_av, ModRdpUseFailureSimulationSocketTransport::Off},
    {"SIMULATEERRORREAD"_av, ModRdpUseFailureSimulationSocketTransport::SimulateErrorRead},
    {"SIMULATEERRORWRITE"_av, ModRdpUseFailureSimulationSocketTransport::SimulateErrorWrite},
};

parse_error parse_from_cfg(ModRdpUseFailureSimulationSocketTransport & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_ModRdpUseFailureSimulationSocketTransport>(
        x, value, "bad value, expected: Off, SimulateErrorRead, SimulateErrorWrite");
}

inline constexpr zstring_view enum_zstr_LoginLanguage[] {
    "Auto"_zv,
    "EN"_zv,
    "FR"_zv,
};

inline constexpr zstring_view enum_zint_LoginLanguage[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<LoginLanguage> /*type*/,
    LoginLanguage x
){
    (void)zbuf;
    assert(is_valid_enum_value<LoginLanguage>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_LoginLanguage[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    LoginLanguage x
){
    (void)zbuf;
    assert(is_valid_enum_value<LoginLanguage>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_LoginLanguage[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(LoginLanguage & x, ::configs::spec_type<LoginLanguage> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<LoginLanguage>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, LoginLanguage> enum_str_value_LoginLanguage[] {
    {"AUTO"_av, LoginLanguage::Auto},
    {"EN"_av, LoginLanguage::EN},
    {"FR"_av, LoginLanguage::FR},
};

parse_error parse_from_cfg(LoginLanguage & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_LoginLanguage>(
        x, value, "bad value, expected: Auto, EN, FR");
}

inline constexpr zstring_view enum_zstr_VncTunnelingType[] {
    "pxssh"_zv,
    "pexpect"_zv,
    "popen"_zv,
};

inline constexpr zstring_view enum_zint_VncTunnelingType[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<VncTunnelingType> /*type*/,
    VncTunnelingType x
){
    (void)zbuf;
    assert(is_valid_enum_value<VncTunnelingType>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_VncTunnelingType[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    VncTunnelingType x
){
    (void)zbuf;
    assert(is_valid_enum_value<VncTunnelingType>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_VncTunnelingType[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(VncTunnelingType & x, ::configs::spec_type<VncTunnelingType> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<VncTunnelingType>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, VncTunnelingType> enum_str_value_VncTunnelingType[] {
    {"PXSSH"_av, VncTunnelingType::pxssh},
    {"PEXPECT"_av, VncTunnelingType::pexpect},
    {"POPEN"_av, VncTunnelingType::popen},
};

parse_error parse_from_cfg(VncTunnelingType & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_VncTunnelingType>(
        x, value, "bad value, expected: pxssh, pexpect, popen");
}

inline constexpr zstring_view enum_zstr_VncTunnelingCredentialSource[] {
    "static_login"_zv,
    "scenario_account"_zv,
};

inline constexpr zstring_view enum_zint_VncTunnelingCredentialSource[] {
    "0"_zv,
    "1"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<VncTunnelingCredentialSource> /*type*/,
    VncTunnelingCredentialSource x
){
    (void)zbuf;
    assert(is_valid_enum_value<VncTunnelingCredentialSource>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_VncTunnelingCredentialSource[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    VncTunnelingCredentialSource x
){
    (void)zbuf;
    assert(is_valid_enum_value<VncTunnelingCredentialSource>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_VncTunnelingCredentialSource[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(VncTunnelingCredentialSource & x, ::configs::spec_type<VncTunnelingCredentialSource> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 1>()
    )) {
        return err;
    }

    x = static_cast<VncTunnelingCredentialSource>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, VncTunnelingCredentialSource> enum_str_value_VncTunnelingCredentialSource[] {
    {"STATIC_LOGIN"_av, VncTunnelingCredentialSource::static_login},
    {"SCENARIO_ACCOUNT"_av, VncTunnelingCredentialSource::scenario_account},
};

parse_error parse_from_cfg(VncTunnelingCredentialSource & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_VncTunnelingCredentialSource>(
        x, value, "bad value, expected: static_login, scenario_account");
}

inline constexpr zstring_view enum_zstr_BannerType[] {
    "info"_zv,
    "warn"_zv,
    "alert"_zv,
};

inline constexpr zstring_view enum_zint_BannerType[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<BannerType> /*type*/,
    BannerType x
){
    (void)zbuf;
    assert(is_valid_enum_value<BannerType>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_BannerType[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    BannerType x
){
    (void)zbuf;
    assert(is_valid_enum_value<BannerType>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_BannerType[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(BannerType & x, ::configs::spec_type<BannerType> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<BannerType>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, BannerType> enum_str_value_BannerType[] {
    {"INFO"_av, BannerType::info},
    {"WARN"_av, BannerType::warn},
    {"ALERT"_av, BannerType::alert},
};

parse_error parse_from_cfg(BannerType & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_BannerType>(
        x, value, "bad value, expected: info, warn, alert");
}

inline constexpr zstring_view enum_zstr_SessionProbeCPUUsageAlarmAction[] {
    "Restart"_zv,
    "Stop"_zv,
};

inline constexpr zstring_view enum_zint_SessionProbeCPUUsageAlarmAction[] {
    "0"_zv,
    "1"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<SessionProbeCPUUsageAlarmAction> /*type*/,
    SessionProbeCPUUsageAlarmAction x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeCPUUsageAlarmAction>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_SessionProbeCPUUsageAlarmAction[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    SessionProbeCPUUsageAlarmAction x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeCPUUsageAlarmAction>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_SessionProbeCPUUsageAlarmAction[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(SessionProbeCPUUsageAlarmAction & x, ::configs::spec_type<SessionProbeCPUUsageAlarmAction> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 1>()
    )) {
        return err;
    }

    x = static_cast<SessionProbeCPUUsageAlarmAction>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, SessionProbeCPUUsageAlarmAction> enum_str_value_SessionProbeCPUUsageAlarmAction[] {
    {"RESTART"_av, SessionProbeCPUUsageAlarmAction::Restart},
    {"STOP"_av, SessionProbeCPUUsageAlarmAction::Stop},
};

parse_error parse_from_cfg(SessionProbeCPUUsageAlarmAction & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_SessionProbeCPUUsageAlarmAction>(
        x, value, "bad value, expected: Restart, Stop");
}

inline constexpr zstring_view enum_zstr_SessionProbeProcessCommandLineRetrieveMethod[] {
    "windows_management_instrumentation"_zv,
    "windows_internals"_zv,
    "both"_zv,
};

inline constexpr zstring_view enum_zint_SessionProbeProcessCommandLineRetrieveMethod[] {
    "0"_zv,
    "1"_zv,
    "2"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<SessionProbeProcessCommandLineRetrieveMethod> /*type*/,
    SessionProbeProcessCommandLineRetrieveMethod x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeProcessCommandLineRetrieveMethod>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_SessionProbeProcessCommandLineRetrieveMethod[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    SessionProbeProcessCommandLineRetrieveMethod x
){
    (void)zbuf;
    assert(is_valid_enum_value<SessionProbeProcessCommandLineRetrieveMethod>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_SessionProbeProcessCommandLineRetrieveMethod[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(SessionProbeProcessCommandLineRetrieveMethod & x, ::configs::spec_type<SessionProbeProcessCommandLineRetrieveMethod> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 2>()
    )) {
        return err;
    }

    x = static_cast<SessionProbeProcessCommandLineRetrieveMethod>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, SessionProbeProcessCommandLineRetrieveMethod> enum_str_value_SessionProbeProcessCommandLineRetrieveMethod[] {
    {"WINDOWS_MANAGEMENT_INSTRUMENTATION"_av, SessionProbeProcessCommandLineRetrieveMethod::windows_management_instrumentation},
    {"WINDOWS_INTERNALS"_av, SessionProbeProcessCommandLineRetrieveMethod::windows_internals},
    {"BOTH"_av, SessionProbeProcessCommandLineRetrieveMethod::both},
};

parse_error parse_from_cfg(SessionProbeProcessCommandLineRetrieveMethod & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_SessionProbeProcessCommandLineRetrieveMethod>(
        x, value, "bad value, expected: windows_management_instrumentation, windows_internals, both");
}

inline constexpr zstring_view enum_zstr_RdpSaveSessionInfoPDU[] {
    "Supported"_zv,
    "UnsupportedOrUnknown"_zv,
};

inline constexpr zstring_view enum_zint_RdpSaveSessionInfoPDU[] {
    "0"_zv,
    "1"_zv,
};

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<RdpSaveSessionInfoPDU> /*type*/,
    RdpSaveSessionInfoPDU x
){
    (void)zbuf;
    assert(is_valid_enum_value<RdpSaveSessionInfoPDU>::is_valid(static_cast<uint8_t>(x)));
    return enum_zint_RdpSaveSessionInfoPDU[static_cast<uint8_t>(x)];
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<std::string> /*type*/,
    RdpSaveSessionInfoPDU x
){
    (void)zbuf;
    assert(is_valid_enum_value<RdpSaveSessionInfoPDU>::is_valid(static_cast<uint8_t>(x)));
    return enum_zstr_RdpSaveSessionInfoPDU[static_cast<uint8_t>(x)];
}

parse_error parse_from_cfg(RdpSaveSessionInfoPDU & x, ::configs::spec_type<RdpSaveSessionInfoPDU> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 1>()
    )) {
        return err;
    }

    x = static_cast<RdpSaveSessionInfoPDU>(xi);
    return no_parse_error;
}


inline constexpr std::pair<chars_view, RdpSaveSessionInfoPDU> enum_str_value_RdpSaveSessionInfoPDU[] {
    {"SUPPORTED"_av, RdpSaveSessionInfoPDU::Supported},
    {"UNSUPPORTEDORUNKNOWN"_av, RdpSaveSessionInfoPDU::UnsupportedOrUnknown},
};

parse_error parse_from_cfg(RdpSaveSessionInfoPDU & x, ::configs::spec_type<std::string> /*type*/, bytes_view value)
{
    return parse_str_value_pairs<enum_str_value_RdpSaveSessionInfoPDU>(
        x, value, "bad value, expected: Supported, UnsupportedOrUnknown");
}

zstring_view assign_zbuf_from_cfg(
    writable_chars_view zbuf,
    cfg_s_type<SessionLogFormat> /*type*/,
    SessionLogFormat x
){
    auto r = std::to_chars(zbuf.begin(), zbuf.end(), static_cast<uint8_t>(x));
    *r.ptr = '\0';
    return zstring_view::from_null_terminated({zbuf.data(), r.ptr});
}

parse_error parse_from_cfg(SessionLogFormat & x, ::configs::spec_type<SessionLogFormat> /*type*/, bytes_view value)
{
    using ul = uint8_t;

    ul xi = 0;
    if (parse_error err = parse_integral(
        xi, value,
        zero_integral<ul>(),
        std::integral_constant<ul, 3>()
    )) {
        return err;
    }

    x = static_cast<SessionLogFormat>(xi);
    return no_parse_error;
}

} // anonymous namespace
